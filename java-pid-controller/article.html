PID Controllers are one of the most widely used control mechanisms in engineering — from industrial automation and robotics to cruise control systems in cars. Despite being everywhere, the underlying algorithm is surprisingly simple. Let's implement one step by step in Java, building up from the simplest proportional controller to a full PID with integral windup protection.

We'll use a cruise control simulation as our running example, which should make the behavior of each controller variant easy to reason about.

<h2>The Control Loop</h2>

The basic idea behind any feedback controller is straightforward: measure the current state, compare it to where you want to be, and adjust accordingly. In control theory terms:

<pre><code class="language-java">double error = setpoint - measured;</code></pre>

The <code>setpoint</code> is our target (e.g., 100 km/h), <code>measured</code> is where we are right now, and <code>error</code> is the gap between the two. What the different controller variants disagree on is <em>how to use that error to compute an output</em>.

<h2>Step 1: Proportional Controller (P)</h2>

The simplest approach — make the output proportional to the error. If we're far from the target, push hard. If we're close, push gently:

<pre><code class="language-java">record PController(double kp) {

    double compute(double setpoint, double measured) {
        double error = setpoint - measured;
        return kp * error;
    }
}</code></pre>

That's it. The gain <code>kp</code> determines how aggressively the controller reacts. A Java record fits perfectly here since the controller is just a function parameterized by its gain.

Let's see how it performs in a cruise control simulation. We'll model a simple vehicle where throttle accelerates the car and drag slows it down:

<pre><code class="language-java">var controller = new PController(1.0);
double speed = 0;

for (int i = 0; i < STEPS; i++) {
    double throttle = controller.compute(TARGET_SPEED, speed);
    speed += (throttle - DRAG * speed) * DT;
}</code></pre>

The physics model is intentionally simple: <code>speed += (throttle - drag * speed) * dt</code>. The drag term means the car needs continuous throttle just to maintain speed — and this is exactly where a P-only controller falls short.

As the car approaches the target speed, the error shrinks, so the throttle output drops. But at the same time, drag keeps pulling the speed down. The result: the controller settles at a speed <em>below</em> the target. This gap that never closes is called <strong>steady-state error</strong>, and it's the fundamental limitation of proportional-only control.

We can confirm this in a test:

<pre><code class="language-java">// P-only controller will have steady-state error due to drag
assertThat(speed).isGreaterThan(90.0).isLessThan(TARGET_SPEED);</code></pre>

Close, but not quite there. We need something more.

<h2>Step 2: Proportional-Derivative Controller (PD)</h2>

One problem with the P controller is that it has no sense of <em>momentum</em>. It doesn't know if the error is growing or shrinking — it only sees the current gap. Adding a derivative term fixes this by looking at the <em>rate of change</em> of the error:

<pre><code class="language-java">class PDController {

    private final double kp;
    private final double kd;

    private double previousError;

    PDController(double kp, double kd) {
        this.kp = kp;
        this.kd = kd;
    }

    double compute(double setpoint, double measured, double dt) {
        double error = setpoint - measured;
        double derivative = (error - previousError) / dt;
        previousError = error;
        return kp * error + kd * derivative;
    }
}</code></pre>

The derivative <code>(error - previousError) / dt</code> is essentially the speed at which the error is changing. When the car is rapidly approaching the target, this term becomes negative, dampening the output and reducing overshoot. Think of it as the controller applying the brakes before it overshoots.

Note that we can no longer use a record since we need to track mutable state (<code>previousError</code>) between calls. The method also now requires <code>dt</code> — the time step — because the derivative depends on <em>how quickly</em> the error changes, not just by how much.

The derivative term improves transient response significantly — less overshoot, smoother approach to the target. But it doesn't help with steady-state error at all. The derivative of a constant error is zero, so in the long run, we're back to the same P-only behavior.

<h2>Step 3: Full PID Controller</h2>

To eliminate steady-state error, we need a term that <em>accumulates</em> error over time. If there's a persistent gap between where we are and where we want to be, the integral term keeps growing until the controller output is large enough to close it:

<pre><code class="language-java">class PIDController {

    private final double kp;
    private final double ki;
    private final double kd;
    private final double outputMin;
    private final double outputMax;

    private double integral;
    private double previousError;

    PIDController(double kp, double ki, double kd,
                  double outputMin, double outputMax) {
        this.kp = kp;
        this.ki = ki;
        this.kd = kd;
        this.outputMin = outputMin;
        this.outputMax = outputMax;
    }

    double compute(double setpoint, double measured, double dt) {
        double error = setpoint - measured;

        integral += error * dt;
        double derivative = (error - previousError) / dt;
        previousError = error;

        double output = kp * error + ki * integral + kd * derivative;

        if (output > outputMax) {
            integral -= error * dt;
            return outputMax;
        }
        if (output < outputMin) {
            integral -= error * dt;
            return outputMin;
        }

        return output;
    }
}</code></pre>

The output formula combines all three terms:

<code>output = Kp * error + Ki * integral + Kd * derivative</code>

Each term handles a different aspect of the control problem:
<ul>
    <li><strong>Proportional (Kp)</strong> — reacts to the <em>present</em> error</li>
    <li><strong>Integral (Ki)</strong> — reacts to the <em>accumulated past</em> error</li>
    <li><strong>Derivative (Kd)</strong> — reacts to the <em>predicted future</em> error (rate of change)</li>
</ul>

<h2>Integral Windup Protection</h2>

There's a subtle but important detail in the implementation above: output clamping with integral rollback. Without it, we'd have a problem called <strong>integral windup</strong>.

Consider what happens during startup: the car is at 0 km/h, the target is 100 km/h, and the error is large. The integral term keeps accumulating this large error every time step. By the time the car reaches the target speed, the integral has grown so large that it takes a long time to "unwind" — causing massive overshoot.

The fix is straightforward: when the output hits the min/max limits, we undo the last integral accumulation:

<pre><code class="language-java">if (output > outputMax) {
    integral -= error * dt; // windup protection
    return outputMax;
}</code></pre>

This way, the integral only accumulates when the controller's output is actually being used. The integral term is free to grow when it can influence the output, but is prevented from winding up when the actuator is saturated.

<h2>Putting It All Together</h2>

With the full PID controller, our cruise control simulation finally reaches the exact target speed:

<pre><code class="language-java">var controller = new PIDController(1.0, 0.5, 0.1, 0, 500);
double speed = 0;

for (int i = 0; i < STEPS; i++) {
    double throttle = controller.compute(TARGET_SPEED, speed, DT);
    speed += (throttle - DRAG * speed) * DT;
}

assertThat(speed).isCloseTo(TARGET_SPEED, within(0.1));</code></pre>

We can also verify that the controller recovers from disturbances — simulating a hill that suddenly drops the speed by 20 km/h:

<pre><code class="language-java">// Simulate a hill (sudden speed drop)
speed -= 20;

// Recover
for (int i = 0; i < STEPS; i++) {
    double throttle = controller.compute(TARGET_SPEED, speed, DT);
    speed += (throttle - DRAG * speed) * DT;
}

assertThat(speed).isCloseTo(TARGET_SPEED, within(0.1));</code></pre>

The integral term is what makes this possible. After the disturbance, the error reappears, the integral starts accumulating again, and the controller ramps up the output until the car is back at the target speed.

<h2>Tuning</h2>

The hardest part of PID control is usually not the implementation — it's choosing good values for <code>Kp</code>, <code>Ki</code>, and <code>Kd</code>. There's no single "correct" set of gains. The right values depend entirely on the system being controlled, and the trade-offs between responsiveness, overshoot, and stability.

A few practical guidelines:
<ul>
    <li>Start with <code>Ki = 0</code> and <code>Kd = 0</code>, tune <code>Kp</code> first until you get a reasonable response</li>
    <li>Add <code>Kd</code> to reduce overshoot and oscillation</li>
    <li>Add <code>Ki</code> last, sparingly, to eliminate steady-state error</li>
    <li>Too much <code>Ki</code> causes oscillation; too much <code>Kd</code> amplifies noise</li>
</ul>

For formal approaches, look into the <em>Ziegler-Nichols method</em> or <em>Cohen-Coon tuning</em> — they provide starting-point gain values based on system response characteristics.

<h2>Source Code</h2>

As always, the source code is available <a href="https://github.com/pivovarit/articles/tree/master/java-pid-controller">on GitHub</a>.
